// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ble_proxy.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// BLE Proxy Protocol Definition
// Version: 1.0.0
// Package: bleproxy.v1
//
// This protocol enables React Native applications running in simulators/emulators
// to communicate with physical BLE peripherals through a macOS proxy server.
//
// Field Numbering Strategy:
// - Fields 1-50: Core required fields
// - Fields 51-80: Optional fields and metadata
// - Fields 81-99: Reserved for future extensions
// - Fields 100+: Complex nested structures
//
// Backward Compatibility:
// - Never reuse deprecated field numbers
// - Use reserved keyword for removed fields
// - Optional fields use the optional keyword
// - Extensions should use field numbers 81+

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Bluetooth adapter state enumeration matching react-native-ble-plx
public enum Bleproxy_V1_ManagerState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Initial state before initialization
  case unknown // = 0

  /// Bluetooth is resetting
  case resetting // = 1

  /// Bluetooth LE not supported on device
  case unsupported // = 2

  /// App not authorized to use Bluetooth
  case unauthorized // = 3

  /// Bluetooth is powered off
  case poweredOff // = 4

  /// Bluetooth is powered on and ready
  case poweredOn // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .resetting
    case 2: self = .unsupported
    case 3: self = .unauthorized
    case 4: self = .poweredOff
    case 5: self = .poweredOn
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .resetting: return 1
    case .unsupported: return 2
    case .unauthorized: return 3
    case .poweredOff: return 4
    case .poweredOn: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Bleproxy_V1_ManagerState] = [
    .unknown,
    .resetting,
    .unsupported,
    .unauthorized,
    .poweredOff,
    .poweredOn,
  ]

}

/// Complete error code enumeration matching react-native-ble-plx
/// Error codes maintain 1:1 mapping with react-native-ble-plx BleErrorCode
public enum Bleproxy_V1_BleErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Implementation Specific (0-99)
  case errorUnknown // = 0
  case errorBluetoothManagerDestroyed // = 1
  case errorOperationCancelled // = 2
  case errorOperationTimedOut // = 3
  case errorOperationStartFailed // = 4
  case errorInvalidIdentifiers // = 5

  /// Bluetooth State (100-199)
  case errorBluetoothUnsupported // = 100
  case errorBluetoothUnauthorized // = 101
  case errorBluetoothPoweredOff // = 102
  case errorBluetoothInUnknownState // = 103
  case errorBluetoothResetting // = 104
  case errorBluetoothStateChangeFailed // = 105

  /// Device/Peripheral (200-299)
  case errorDeviceConnectionFailed // = 200
  case errorDeviceDisconnected // = 201
  case errorDeviceRssiReadFailed // = 202
  case errorDeviceAlreadyConnected // = 203
  case errorDeviceNotFound // = 204
  case errorDeviceNotConnected // = 205
  case errorDeviceMtuChangeFailed // = 206

  /// Services (300-399)
  case errorServicesDiscoveryFailed // = 300
  case errorIncludedServicesDiscoveryFailed // = 301
  case errorServiceNotFound // = 302
  case errorServicesNotDiscovered // = 303

  /// Characteristics (400-499)
  case errorCharacteristicsDiscoveryFailed // = 400
  case errorCharacteristicWriteFailed // = 401
  case errorCharacteristicReadFailed // = 402
  case errorCharacteristicNotifyChangeFailed // = 403
  case errorCharacteristicNotFound // = 404
  case errorCharacteristicsNotDiscovered // = 405
  case errorCharacteristicInvalidDataFormat // = 406

  /// Descriptors (500-599)
  case errorDescriptorsDiscoveryFailed // = 500
  case errorDescriptorWriteFailed // = 501
  case errorDescriptorReadFailed // = 502
  case errorDescriptorNotFound // = 503
  case errorDescriptorsNotDiscovered // = 504
  case errorDescriptorInvalidDataFormat // = 505
  case errorDescriptorWriteNotAllowed // = 506

  /// Scanning (600-699)
  case errorScanStartFailed // = 600
  case errorLocationServicesDisabled // = 601

  /// Server-specific (1000+)
  case errorServerError // = 1000
  case errorServerTimeout // = 1001
  case errorServerUnavailable // = 1002
  case errorProtocolError // = 1003
  case UNRECOGNIZED(Int)

  public init() {
    self = .errorUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .errorUnknown
    case 1: self = .errorBluetoothManagerDestroyed
    case 2: self = .errorOperationCancelled
    case 3: self = .errorOperationTimedOut
    case 4: self = .errorOperationStartFailed
    case 5: self = .errorInvalidIdentifiers
    case 100: self = .errorBluetoothUnsupported
    case 101: self = .errorBluetoothUnauthorized
    case 102: self = .errorBluetoothPoweredOff
    case 103: self = .errorBluetoothInUnknownState
    case 104: self = .errorBluetoothResetting
    case 105: self = .errorBluetoothStateChangeFailed
    case 200: self = .errorDeviceConnectionFailed
    case 201: self = .errorDeviceDisconnected
    case 202: self = .errorDeviceRssiReadFailed
    case 203: self = .errorDeviceAlreadyConnected
    case 204: self = .errorDeviceNotFound
    case 205: self = .errorDeviceNotConnected
    case 206: self = .errorDeviceMtuChangeFailed
    case 300: self = .errorServicesDiscoveryFailed
    case 301: self = .errorIncludedServicesDiscoveryFailed
    case 302: self = .errorServiceNotFound
    case 303: self = .errorServicesNotDiscovered
    case 400: self = .errorCharacteristicsDiscoveryFailed
    case 401: self = .errorCharacteristicWriteFailed
    case 402: self = .errorCharacteristicReadFailed
    case 403: self = .errorCharacteristicNotifyChangeFailed
    case 404: self = .errorCharacteristicNotFound
    case 405: self = .errorCharacteristicsNotDiscovered
    case 406: self = .errorCharacteristicInvalidDataFormat
    case 500: self = .errorDescriptorsDiscoveryFailed
    case 501: self = .errorDescriptorWriteFailed
    case 502: self = .errorDescriptorReadFailed
    case 503: self = .errorDescriptorNotFound
    case 504: self = .errorDescriptorsNotDiscovered
    case 505: self = .errorDescriptorInvalidDataFormat
    case 506: self = .errorDescriptorWriteNotAllowed
    case 600: self = .errorScanStartFailed
    case 601: self = .errorLocationServicesDisabled
    case 1000: self = .errorServerError
    case 1001: self = .errorServerTimeout
    case 1002: self = .errorServerUnavailable
    case 1003: self = .errorProtocolError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .errorUnknown: return 0
    case .errorBluetoothManagerDestroyed: return 1
    case .errorOperationCancelled: return 2
    case .errorOperationTimedOut: return 3
    case .errorOperationStartFailed: return 4
    case .errorInvalidIdentifiers: return 5
    case .errorBluetoothUnsupported: return 100
    case .errorBluetoothUnauthorized: return 101
    case .errorBluetoothPoweredOff: return 102
    case .errorBluetoothInUnknownState: return 103
    case .errorBluetoothResetting: return 104
    case .errorBluetoothStateChangeFailed: return 105
    case .errorDeviceConnectionFailed: return 200
    case .errorDeviceDisconnected: return 201
    case .errorDeviceRssiReadFailed: return 202
    case .errorDeviceAlreadyConnected: return 203
    case .errorDeviceNotFound: return 204
    case .errorDeviceNotConnected: return 205
    case .errorDeviceMtuChangeFailed: return 206
    case .errorServicesDiscoveryFailed: return 300
    case .errorIncludedServicesDiscoveryFailed: return 301
    case .errorServiceNotFound: return 302
    case .errorServicesNotDiscovered: return 303
    case .errorCharacteristicsDiscoveryFailed: return 400
    case .errorCharacteristicWriteFailed: return 401
    case .errorCharacteristicReadFailed: return 402
    case .errorCharacteristicNotifyChangeFailed: return 403
    case .errorCharacteristicNotFound: return 404
    case .errorCharacteristicsNotDiscovered: return 405
    case .errorCharacteristicInvalidDataFormat: return 406
    case .errorDescriptorsDiscoveryFailed: return 500
    case .errorDescriptorWriteFailed: return 501
    case .errorDescriptorReadFailed: return 502
    case .errorDescriptorNotFound: return 503
    case .errorDescriptorsNotDiscovered: return 504
    case .errorDescriptorInvalidDataFormat: return 505
    case .errorDescriptorWriteNotAllowed: return 506
    case .errorScanStartFailed: return 600
    case .errorLocationServicesDisabled: return 601
    case .errorServerError: return 1000
    case .errorServerTimeout: return 1001
    case .errorServerUnavailable: return 1002
    case .errorProtocolError: return 1003
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Bleproxy_V1_BleErrorCode] = [
    .errorUnknown,
    .errorBluetoothManagerDestroyed,
    .errorOperationCancelled,
    .errorOperationTimedOut,
    .errorOperationStartFailed,
    .errorInvalidIdentifiers,
    .errorBluetoothUnsupported,
    .errorBluetoothUnauthorized,
    .errorBluetoothPoweredOff,
    .errorBluetoothInUnknownState,
    .errorBluetoothResetting,
    .errorBluetoothStateChangeFailed,
    .errorDeviceConnectionFailed,
    .errorDeviceDisconnected,
    .errorDeviceRssiReadFailed,
    .errorDeviceAlreadyConnected,
    .errorDeviceNotFound,
    .errorDeviceNotConnected,
    .errorDeviceMtuChangeFailed,
    .errorServicesDiscoveryFailed,
    .errorIncludedServicesDiscoveryFailed,
    .errorServiceNotFound,
    .errorServicesNotDiscovered,
    .errorCharacteristicsDiscoveryFailed,
    .errorCharacteristicWriteFailed,
    .errorCharacteristicReadFailed,
    .errorCharacteristicNotifyChangeFailed,
    .errorCharacteristicNotFound,
    .errorCharacteristicsNotDiscovered,
    .errorCharacteristicInvalidDataFormat,
    .errorDescriptorsDiscoveryFailed,
    .errorDescriptorWriteFailed,
    .errorDescriptorReadFailed,
    .errorDescriptorNotFound,
    .errorDescriptorsNotDiscovered,
    .errorDescriptorInvalidDataFormat,
    .errorDescriptorWriteNotAllowed,
    .errorScanStartFailed,
    .errorLocationServicesDisabled,
    .errorServerError,
    .errorServerTimeout,
    .errorServerUnavailable,
    .errorProtocolError,
  ]

}

/// Error message with code, description, and optional platform-specific details
public struct Bleproxy_V1_Error: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error code from BleErrorCode enum
  public var code: Int32 = 0

  /// Human-readable error message
  public var message: String = String()

  /// Optional ATT (Attribute Protocol) error code for GATT operations
  /// Values 0x01-0xFF from Bluetooth Core Spec Vol 3, Part F, Section 3.4.1.1
  public var attErrorCode: Int32 {
    get {return _attErrorCode ?? 0}
    set {_attErrorCode = newValue}
  }
  /// Returns true if `attErrorCode` has been explicitly set.
  public var hasAttErrorCode: Bool {return self._attErrorCode != nil}
  /// Clears the value of `attErrorCode`. Subsequent reads from it will return its default value.
  public mutating func clearAttErrorCode() {self._attErrorCode = nil}

  /// Original platform error string (for debugging)
  public var platformError: String {
    get {return _platformError ?? String()}
    set {_platformError = newValue}
  }
  /// Returns true if `platformError` has been explicitly set.
  public var hasPlatformError: Bool {return self._platformError != nil}
  /// Clears the value of `platformError`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformError() {self._platformError = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attErrorCode: Int32? = nil
  fileprivate var _platformError: String? = nil
}

/// GATT Descriptor
public struct Bleproxy_V1_Descriptor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Descriptor UUID (e.g., "00002902-0000-1000-8000-00805f9b34fb" for CCCD)
  public var uuid: String = String()

  /// Descriptor value (if read)
  public var value: Data {
    get {return _value ?? Data()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Data? = nil
}

/// GATT Characteristic
public struct Bleproxy_V1_Characteristic: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Characteristic UUID
  public var uuid: String = String()

  /// Characteristic properties as string array
  /// Possible values: "broadcast", "read", "writeWithoutResponse", "write",
  ///                  "notify", "indicate", "authenticatedSignedWrites", "extendedProperties"
  public var properties: [String] = []

  /// Descriptors for this characteristic
  public var descriptors: [Bleproxy_V1_Descriptor] = []

  /// Characteristic value (if read)
  public var value: Data {
    get {return _value ?? Data()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _value: Data? = nil
}

/// GATT Service
public struct Bleproxy_V1_Service: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Service UUID (128-bit or 16-bit)
  public var uuid: String = String()

  /// Characteristics in this service
  public var characteristics: [Bleproxy_V1_Characteristic] = []

  /// Whether this is a primary or secondary service
  public var isPrimary: Bool {
    get {return _isPrimary ?? false}
    set {_isPrimary = newValue}
  }
  /// Returns true if `isPrimary` has been explicitly set.
  public var hasIsPrimary: Bool {return self._isPrimary != nil}
  /// Clears the value of `isPrimary`. Subsequent reads from it will return its default value.
  public mutating func clearIsPrimary() {self._isPrimary = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _isPrimary: Bool? = nil
}

/// BLE Device representation
public struct Bleproxy_V1_Device: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device identifier (CBPeripheral.identifier.uuidString on iOS)
  public var id: String = String()

  /// Local name from advertisement data
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// RSSI in dBm (-100 to 0)
  public var rssi: Int32 {
    get {return _rssi ?? 0}
    set {_rssi = newValue}
  }
  /// Returns true if `rssi` has been explicitly set.
  public var hasRssi: Bool {return self._rssi != nil}
  /// Clears the value of `rssi`. Subsequent reads from it will return its default value.
  public mutating func clearRssi() {self._rssi = nil}

  /// MTU (Maximum Transmission Unit) in bytes
  public var mtu: Int32 {
    get {return _mtu ?? 0}
    set {_mtu = newValue}
  }
  /// Returns true if `mtu` has been explicitly set.
  public var hasMtu: Bool {return self._mtu != nil}
  /// Clears the value of `mtu`. Subsequent reads from it will return its default value.
  public mutating func clearMtu() {self._mtu = nil}

  /// Manufacturer-specific data from advertisement
  public var manufacturerData: Data {
    get {return _manufacturerData ?? Data()}
    set {_manufacturerData = newValue}
  }
  /// Returns true if `manufacturerData` has been explicitly set.
  public var hasManufacturerData: Bool {return self._manufacturerData != nil}
  /// Clears the value of `manufacturerData`. Subsequent reads from it will return its default value.
  public mutating func clearManufacturerData() {self._manufacturerData = nil}

  /// Advertised service UUIDs
  public var serviceUuids: [String] = []

  /// Service-specific data from advertisement
  public var serviceData: Dictionary<String,Data> = [:]

  /// TX power level from advertisement
  public var txPowerLevel: Int32 {
    get {return _txPowerLevel ?? 0}
    set {_txPowerLevel = newValue}
  }
  /// Returns true if `txPowerLevel` has been explicitly set.
  public var hasTxPowerLevel: Bool {return self._txPowerLevel != nil}
  /// Clears the value of `txPowerLevel`. Subsequent reads from it will return its default value.
  public mutating func clearTxPowerLevel() {self._txPowerLevel = nil}

  /// Whether device is connectable
  public var isConnectable: Bool {
    get {return _isConnectable ?? false}
    set {_isConnectable = newValue}
  }
  /// Returns true if `isConnectable` has been explicitly set.
  public var hasIsConnectable: Bool {return self._isConnectable != nil}
  /// Clears the value of `isConnectable`. Subsequent reads from it will return its default value.
  public mutating func clearIsConnectable() {self._isConnectable = nil}

  /// Solicited service UUIDs
  public var solicitedServiceUuids: [String] = []

  /// Overflow service UUIDs
  public var overflowServiceUuids: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _rssi: Int32? = nil
  fileprivate var _mtu: Int32? = nil
  fileprivate var _manufacturerData: Data? = nil
  fileprivate var _txPowerLevel: Int32? = nil
  fileprivate var _isConnectable: Bool? = nil
}

/// Empty request body
public struct Bleproxy_V1_HealthRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_HealthResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether server is ready to accept BLE requests
  public var ready: Bool = false

  /// Server version (e.g., "1.0.0")
  public var serverVersion: String = String()

  /// Protocol version (e.g., "v1")
  public var protocolVersion: String = String()

  /// Current Bluetooth adapter state
  public var bluetoothState: Bleproxy_V1_ManagerState = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Empty request body
public struct Bleproxy_V1_StateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_StateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current manager state
  public var state: Bleproxy_V1_ManagerState = .unknown

  /// Error if state cannot be determined
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

public struct Bleproxy_V1_StartScanRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filter by service UUIDs (empty array scans for all devices)
  public var serviceUuids: [String] = []

  /// Scan options
  /// Common keys: "allowDuplicates" (bool), "scanMode" (Android)
  public var options: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_StartScanResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether scan started successfully
  public var success: Bool = false

  /// Error if scan failed to start
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

/// Empty request body
public struct Bleproxy_V1_StopScanRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_StopScanResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether scan stopped successfully
  public var success: Bool = false

  /// Error if scan failed to stop
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

public struct Bleproxy_V1_ConnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID to connect to (from scan results)
  public var deviceID: String = String()

  /// Connection options
  /// Common keys: "timeout" (ms), "autoConnect" (bool, Android)
  public var options: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_ConnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether connection succeeded
  public var success: Bool = false

  /// Error if connection failed
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  /// Connected device information
  public var device: Bleproxy_V1_Device {
    get {return _device ?? Bleproxy_V1_Device()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {self._device = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
  fileprivate var _device: Bleproxy_V1_Device? = nil
}

public struct Bleproxy_V1_DisconnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID to disconnect
  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_DisconnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether disconnection succeeded
  public var success: Bool = false

  /// Error if disconnection failed
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

public struct Bleproxy_V1_IsConnectedRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID to check
  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_IsConnectedResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether device is currently connected
  public var isConnected: Bool = false

  /// Error if connection state cannot be determined
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

public struct Bleproxy_V1_DiscoverRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID to discover services for (must be connected)
  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_DiscoverResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Discovered services with their characteristics
  public var services: [Bleproxy_V1_Service] = []

  /// Error if discovery failed
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

public struct Bleproxy_V1_ServicesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID to get services for
  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_ServicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cached services for this device
  public var services: [Bleproxy_V1_Service] = []

  /// Error if services not available
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

public struct Bleproxy_V1_CharacteristicsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID
  public var deviceID: String = String()

  /// Service UUID to get characteristics for
  public var serviceUuid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_CharacteristicsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Characteristics for the specified service
  public var characteristics: [Bleproxy_V1_Characteristic] = []

  /// Error if characteristics not available
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

public struct Bleproxy_V1_ReadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID
  public var deviceID: String = String()

  /// Service UUID
  public var serviceUuid: String = String()

  /// Characteristic UUID to read
  public var characteristicUuid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_ReadResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Characteristic value (empty if read failed)
  public var value: Data = Data()

  /// Error if read failed
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

public struct Bleproxy_V1_WriteRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID
  public var deviceID: String = String()

  /// Service UUID
  public var serviceUuid: String = String()

  /// Characteristic UUID to write
  public var characteristicUuid: String = String()

  /// Value to write
  public var value: Data = Data()

  /// Whether to request write confirmation from peripheral
  public var withResponse: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_WriteResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether write succeeded
  public var success: Bool = false

  /// Error if write failed
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

public struct Bleproxy_V1_MonitorRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID
  public var deviceID: String = String()

  /// Service UUID
  public var serviceUuid: String = String()

  /// Characteristic UUID to monitor
  public var characteristicUuid: String = String()

  /// Whether to enable (true) or disable (false) monitoring
  public var enable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_MonitorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether monitor operation succeeded
  public var success: Bool = false

  /// Error if monitor operation failed
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

public struct Bleproxy_V1_RSSIRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID to read RSSI for (must be connected)
  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Bleproxy_V1_RSSIResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RSSI value in dBm (typically -100 to 0)
  public var rssi: Int32 = 0

  /// Error if RSSI read failed
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

/// Manager state change event
public struct Bleproxy_V1_ManagerStateEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// New manager state
  public var state: Bleproxy_V1_ManagerState = .unknown

  /// Timestamp (Unix milliseconds)
  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Scan result event (peripheral discovered)
public struct Bleproxy_V1_ScanResultEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device information
  public var device: Bleproxy_V1_Device {
    get {return _device ?? Bleproxy_V1_Device()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {self._device = nil}

  /// Timestamp of discovery (Unix milliseconds)
  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _device: Bleproxy_V1_Device? = nil
}

/// Peripheral connected event
public struct Bleproxy_V1_PeripheralConnectedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID that connected
  public var deviceID: String = String()

  /// Timestamp (Unix milliseconds)
  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Peripheral disconnected event
public struct Bleproxy_V1_PeripheralDisconnectedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID that disconnected
  public var deviceID: String = String()

  /// Error if disconnection was unexpected
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  /// Timestamp (Unix milliseconds)
  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
}

/// Characteristic value update event (notification/indication)
public struct Bleproxy_V1_CharacteristicValueUpdatedEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device ID
  public var deviceID: String = String()

  /// Service UUID
  public var serviceUuid: String = String()

  /// Characteristic UUID
  public var characteristicUuid: String = String()

  /// New characteristic value
  public var value: Data = Data()

  /// Timestamp (Unix milliseconds)
  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Server error event
public struct Bleproxy_V1_ServerErrorEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error information
  public var error: Bleproxy_V1_Error {
    get {return _error ?? Bleproxy_V1_Error()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  /// Timestamp (Unix milliseconds)
  public var timestamp: Int64 = 0

  /// Optional context about what operation failed
  public var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {self._context = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _error: Bleproxy_V1_Error? = nil
  fileprivate var _context: String? = nil
}

/// WebSocket event wrapper
/// This message wraps all WebSocket events for proper framing and deserialization
/// Clients should decode WsEvent and then use the oneof discriminator to determine event type
public struct Bleproxy_V1_WsEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var event: Bleproxy_V1_WsEvent.OneOf_Event? = nil

  public var managerStateEvent: Bleproxy_V1_ManagerStateEvent {
    get {
      if case .managerStateEvent(let v)? = event {return v}
      return Bleproxy_V1_ManagerStateEvent()
    }
    set {event = .managerStateEvent(newValue)}
  }

  public var scanResultEvent: Bleproxy_V1_ScanResultEvent {
    get {
      if case .scanResultEvent(let v)? = event {return v}
      return Bleproxy_V1_ScanResultEvent()
    }
    set {event = .scanResultEvent(newValue)}
  }

  public var peripheralConnectedEvent: Bleproxy_V1_PeripheralConnectedEvent {
    get {
      if case .peripheralConnectedEvent(let v)? = event {return v}
      return Bleproxy_V1_PeripheralConnectedEvent()
    }
    set {event = .peripheralConnectedEvent(newValue)}
  }

  public var peripheralDisconnectedEvent: Bleproxy_V1_PeripheralDisconnectedEvent {
    get {
      if case .peripheralDisconnectedEvent(let v)? = event {return v}
      return Bleproxy_V1_PeripheralDisconnectedEvent()
    }
    set {event = .peripheralDisconnectedEvent(newValue)}
  }

  public var characteristicValueUpdatedEvent: Bleproxy_V1_CharacteristicValueUpdatedEvent {
    get {
      if case .characteristicValueUpdatedEvent(let v)? = event {return v}
      return Bleproxy_V1_CharacteristicValueUpdatedEvent()
    }
    set {event = .characteristicValueUpdatedEvent(newValue)}
  }

  public var serverErrorEvent: Bleproxy_V1_ServerErrorEvent {
    get {
      if case .serverErrorEvent(let v)? = event {return v}
      return Bleproxy_V1_ServerErrorEvent()
    }
    set {event = .serverErrorEvent(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Event: Equatable, Sendable {
    case managerStateEvent(Bleproxy_V1_ManagerStateEvent)
    case scanResultEvent(Bleproxy_V1_ScanResultEvent)
    case peripheralConnectedEvent(Bleproxy_V1_PeripheralConnectedEvent)
    case peripheralDisconnectedEvent(Bleproxy_V1_PeripheralDisconnectedEvent)
    case characteristicValueUpdatedEvent(Bleproxy_V1_CharacteristicValueUpdatedEvent)
    case serverErrorEvent(Bleproxy_V1_ServerErrorEvent)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "bleproxy.v1"

extension Bleproxy_V1_ManagerState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MANAGER_STATE_UNKNOWN\0\u{1}MANAGER_STATE_RESETTING\0\u{1}MANAGER_STATE_UNSUPPORTED\0\u{1}MANAGER_STATE_UNAUTHORIZED\0\u{1}MANAGER_STATE_POWERED_OFF\0\u{1}MANAGER_STATE_POWERED_ON\0")
}

extension Bleproxy_V1_BleErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ERROR_UNKNOWN\0\u{1}ERROR_BLUETOOTH_MANAGER_DESTROYED\0\u{1}ERROR_OPERATION_CANCELLED\0\u{1}ERROR_OPERATION_TIMED_OUT\0\u{1}ERROR_OPERATION_START_FAILED\0\u{1}ERROR_INVALID_IDENTIFIERS\0\u{2}_\u{1}ERROR_BLUETOOTH_UNSUPPORTED\0\u{1}ERROR_BLUETOOTH_UNAUTHORIZED\0\u{1}ERROR_BLUETOOTH_POWERED_OFF\0\u{1}ERROR_BLUETOOTH_IN_UNKNOWN_STATE\0\u{1}ERROR_BLUETOOTH_RESETTING\0\u{1}ERROR_BLUETOOTH_STATE_CHANGE_FAILED\0\u{2}_\u{1}ERROR_DEVICE_CONNECTION_FAILED\0\u{1}ERROR_DEVICE_DISCONNECTED\0\u{1}ERROR_DEVICE_RSSI_READ_FAILED\0\u{1}ERROR_DEVICE_ALREADY_CONNECTED\0\u{1}ERROR_DEVICE_NOT_FOUND\0\u{1}ERROR_DEVICE_NOT_CONNECTED\0\u{1}ERROR_DEVICE_MTU_CHANGE_FAILED\0\u{2}^\u{1}ERROR_SERVICES_DISCOVERY_FAILED\0\u{1}ERROR_INCLUDED_SERVICES_DISCOVERY_FAILED\0\u{1}ERROR_SERVICE_NOT_FOUND\0\u{1}ERROR_SERVICES_NOT_DISCOVERED\0\u{2}a\u{1}ERROR_CHARACTERISTICS_DISCOVERY_FAILED\0\u{1}ERROR_CHARACTERISTIC_WRITE_FAILED\0\u{1}ERROR_CHARACTERISTIC_READ_FAILED\0\u{1}ERROR_CHARACTERISTIC_NOTIFY_CHANGE_FAILED\0\u{1}ERROR_CHARACTERISTIC_NOT_FOUND\0\u{1}ERROR_CHARACTERISTICS_NOT_DISCOVERED\0\u{1}ERROR_CHARACTERISTIC_INVALID_DATA_FORMAT\0\u{2}^\u{1}ERROR_DESCRIPTORS_DISCOVERY_FAILED\0\u{1}ERROR_DESCRIPTOR_WRITE_FAILED\0\u{1}ERROR_DESCRIPTOR_READ_FAILED\0\u{1}ERROR_DESCRIPTOR_NOT_FOUND\0\u{1}ERROR_DESCRIPTORS_NOT_DISCOVERED\0\u{1}ERROR_DESCRIPTOR_INVALID_DATA_FORMAT\0\u{1}ERROR_DESCRIPTOR_WRITE_NOT_ALLOWED\0\u{2}^\u{1}ERROR_SCAN_START_FAILED\0\u{1}ERROR_LOCATION_SERVICES_DISABLED\0\u{2}O\u{6}ERROR_SERVER_ERROR\0\u{1}ERROR_SERVER_TIMEOUT\0\u{1}ERROR_SERVER_UNAVAILABLE\0\u{1}ERROR_PROTOCOL_ERROR\0")
}

extension Bleproxy_V1_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Error"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}code\0\u{1}message\0\u{3}att_error_code\0\u{3}platform_error\0\u{c}\u{5}\u{6}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._attErrorCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._platformError) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._attErrorCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._platformError {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_Error, rhs: Bleproxy_V1_Error) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs._attErrorCode != rhs._attErrorCode {return false}
    if lhs._platformError != rhs._platformError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_Descriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Descriptor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuid\0\u{1}value\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    try { if let v = self._value {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_Descriptor, rhs: Bleproxy_V1_Descriptor) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_Characteristic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Characteristic"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuid\0\u{1}properties\0\u{1}descriptors\0\u{1}value\0\u{c}\u{5}\u{6}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.properties) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.descriptors) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.properties.isEmpty {
      try visitor.visitRepeatedStringField(value: self.properties, fieldNumber: 2)
    }
    if !self.descriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.descriptors, fieldNumber: 3)
    }
    try { if let v = self._value {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_Characteristic, rhs: Bleproxy_V1_Characteristic) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.descriptors != rhs.descriptors {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_Service: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Service"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuid\0\u{1}characteristics\0\u{3}is_primary\0\u{c}\u{4}\u{7}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.characteristics) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isPrimary) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.characteristics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristics, fieldNumber: 2)
    }
    try { if let v = self._isPrimary {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_Service, rhs: Bleproxy_V1_Service) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.characteristics != rhs.characteristics {return false}
    if lhs._isPrimary != rhs._isPrimary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}rssi\0\u{1}mtu\0\u{3}manufacturer_data\0\u{3}service_uuids\0\u{3}service_data\0\u{3}tx_power_level\0\u{3}is_connectable\0\u{3}solicited_service_uuids\0\u{3}overflow_service_uuids\0\u{c}\u{c}\u{9}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._rssi) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._mtu) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._manufacturerData) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.serviceUuids) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.serviceData) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._txPowerLevel) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._isConnectable) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.solicitedServiceUuids) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.overflowServiceUuids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._rssi {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mtu {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._manufacturerData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    if !self.serviceUuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serviceUuids, fieldNumber: 6)
    }
    if !self.serviceData.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.serviceData, fieldNumber: 7)
    }
    try { if let v = self._txPowerLevel {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._isConnectable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    if !self.solicitedServiceUuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.solicitedServiceUuids, fieldNumber: 10)
    }
    if !self.overflowServiceUuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.overflowServiceUuids, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_Device, rhs: Bleproxy_V1_Device) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._name != rhs._name {return false}
    if lhs._rssi != rhs._rssi {return false}
    if lhs._mtu != rhs._mtu {return false}
    if lhs._manufacturerData != rhs._manufacturerData {return false}
    if lhs.serviceUuids != rhs.serviceUuids {return false}
    if lhs.serviceData != rhs.serviceData {return false}
    if lhs._txPowerLevel != rhs._txPowerLevel {return false}
    if lhs._isConnectable != rhs._isConnectable {return false}
    if lhs.solicitedServiceUuids != rhs.solicitedServiceUuids {return false}
    if lhs.overflowServiceUuids != rhs.overflowServiceUuids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_HealthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_HealthRequest, rhs: Bleproxy_V1_HealthRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_HealthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ready\0\u{3}server_version\0\u{3}protocol_version\0\u{3}bluetooth_state\0\u{c}\u{5}\u{6}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ready) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.protocolVersion) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.bluetoothState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ready != false {
      try visitor.visitSingularBoolField(value: self.ready, fieldNumber: 1)
    }
    if !self.serverVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 2)
    }
    if !self.protocolVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolVersion, fieldNumber: 3)
    }
    if self.bluetoothState != .unknown {
      try visitor.visitSingularEnumField(value: self.bluetoothState, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_HealthResponse, rhs: Bleproxy_V1_HealthResponse) -> Bool {
    if lhs.ready != rhs.ready {return false}
    if lhs.serverVersion != rhs.serverVersion {return false}
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.bluetoothState != rhs.bluetoothState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_StateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_StateRequest, rhs: Bleproxy_V1_StateRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_StateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}state\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_StateResponse, rhs: Bleproxy_V1_StateResponse) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_StartScanRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartScanRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_uuids\0\u{1}options\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.serviceUuids) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceUuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serviceUuids, fieldNumber: 1)
    }
    if !self.options.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.options, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_StartScanRequest, rhs: Bleproxy_V1_StartScanRequest) -> Bool {
    if lhs.serviceUuids != rhs.serviceUuids {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_StartScanResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartScanResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_StartScanResponse, rhs: Bleproxy_V1_StartScanResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_StopScanRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopScanRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_StopScanRequest, rhs: Bleproxy_V1_StopScanRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_StopScanResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopScanResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_StopScanResponse, rhs: Bleproxy_V1_StopScanResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{1}options\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.options.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.options, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_ConnectRequest, rhs: Bleproxy_V1_ConnectRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{1}device\0\u{c}\u{4}\u{7}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_ConnectResponse, rhs: Bleproxy_V1_ConnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{c}\u{2}\u{9}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_DisconnectRequest, rhs: Bleproxy_V1_DisconnectRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisconnectResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_DisconnectResponse, rhs: Bleproxy_V1_DisconnectResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_IsConnectedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsConnectedRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{c}\u{2}\u{9}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_IsConnectedRequest, rhs: Bleproxy_V1_IsConnectedRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_IsConnectedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsConnectedResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_connected\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isConnected) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.isConnected != false {
      try visitor.visitSingularBoolField(value: self.isConnected, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_IsConnectedResponse, rhs: Bleproxy_V1_IsConnectedResponse) -> Bool {
    if lhs.isConnected != rhs.isConnected {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_DiscoverRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoverRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{c}\u{2}\u{9}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_DiscoverRequest, rhs: Bleproxy_V1_DiscoverRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_DiscoverResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoverResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}services\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_DiscoverResponse, rhs: Bleproxy_V1_DiscoverResponse) -> Bool {
    if lhs.services != rhs.services {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_ServicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServicesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{c}\u{2}\u{9}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_ServicesRequest, rhs: Bleproxy_V1_ServicesRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_ServicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServicesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}services\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_ServicesResponse, rhs: Bleproxy_V1_ServicesResponse) -> Bool {
    if lhs.services != rhs.services {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_CharacteristicsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacteristicsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{3}service_uuid\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_CharacteristicsRequest, rhs: Bleproxy_V1_CharacteristicsRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_CharacteristicsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacteristicsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}characteristics\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.characteristics) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.characteristics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristics, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_CharacteristicsResponse, rhs: Bleproxy_V1_CharacteristicsResponse) -> Bool {
    if lhs.characteristics != rhs.characteristics {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_ReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{3}service_uuid\0\u{3}characteristic_uuid\0\u{c}\u{4}\u{7}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.characteristicUuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 2)
    }
    if !self.characteristicUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.characteristicUuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_ReadRequest, rhs: Bleproxy_V1_ReadRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.characteristicUuid != rhs.characteristicUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_ReadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_ReadResponse, rhs: Bleproxy_V1_ReadResponse) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_WriteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{3}service_uuid\0\u{3}characteristic_uuid\0\u{1}value\0\u{3}with_response\0\u{c}\u{6}\u{5}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.characteristicUuid) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.withResponse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 2)
    }
    if !self.characteristicUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.characteristicUuid, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 4)
    }
    if self.withResponse != false {
      try visitor.visitSingularBoolField(value: self.withResponse, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_WriteRequest, rhs: Bleproxy_V1_WriteRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.characteristicUuid != rhs.characteristicUuid {return false}
    if lhs.value != rhs.value {return false}
    if lhs.withResponse != rhs.withResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_WriteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_WriteResponse, rhs: Bleproxy_V1_WriteResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_MonitorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MonitorRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{3}service_uuid\0\u{3}characteristic_uuid\0\u{1}enable\0\u{c}\u{5}\u{6}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.characteristicUuid) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 2)
    }
    if !self.characteristicUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.characteristicUuid, fieldNumber: 3)
    }
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_MonitorRequest, rhs: Bleproxy_V1_MonitorRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.characteristicUuid != rhs.characteristicUuid {return false}
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_MonitorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MonitorResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_MonitorResponse, rhs: Bleproxy_V1_MonitorResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_RSSIRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RSSIRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{c}\u{2}\u{9}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_RSSIRequest, rhs: Bleproxy_V1_RSSIRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_RSSIResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RSSIResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rssi\0\u{1}error\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rssi) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.rssi != 0 {
      try visitor.visitSingularInt32Field(value: self.rssi, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_RSSIResponse, rhs: Bleproxy_V1_RSSIResponse) -> Bool {
    if lhs.rssi != rhs.rssi {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_ManagerStateEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagerStateEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}state\0\u{1}timestamp\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_ManagerStateEvent, rhs: Bleproxy_V1_ManagerStateEvent) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_ScanResultEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScanResultEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}device\0\u{1}timestamp\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_ScanResultEvent, rhs: Bleproxy_V1_ScanResultEvent) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_PeripheralConnectedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PeripheralConnectedEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{1}timestamp\0\u{c}\u{3}\u{8}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_PeripheralConnectedEvent, rhs: Bleproxy_V1_PeripheralConnectedEvent) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_PeripheralDisconnectedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PeripheralDisconnectedEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{1}error\0\u{1}timestamp\0\u{c}\u{4}\u{7}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_PeripheralDisconnectedEvent, rhs: Bleproxy_V1_PeripheralDisconnectedEvent) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._error != rhs._error {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_CharacteristicValueUpdatedEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CharacteristicValueUpdatedEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{3}service_uuid\0\u{3}characteristic_uuid\0\u{1}value\0\u{1}timestamp\0\u{c}\u{6}\u{5}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.characteristicUuid) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.serviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceUuid, fieldNumber: 2)
    }
    if !self.characteristicUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.characteristicUuid, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_CharacteristicValueUpdatedEvent, rhs: Bleproxy_V1_CharacteristicValueUpdatedEvent) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.serviceUuid != rhs.serviceUuid {return false}
    if lhs.characteristicUuid != rhs.characteristicUuid {return false}
    if lhs.value != rhs.value {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_ServerErrorEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerErrorEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}error\0\u{1}timestamp\0\u{1}context\0\u{c}\u{4}\u{7}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_ServerErrorEvent, rhs: Bleproxy_V1_ServerErrorEvent) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._context != rhs._context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Bleproxy_V1_WsEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WsEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}manager_state_event\0\u{3}scan_result_event\0\u{3}peripheral_connected_event\0\u{3}peripheral_disconnected_event\0\u{3}characteristic_value_updated_event\0\u{3}server_error_event\0\u{c}\u{7}\u{e}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bleproxy_V1_ManagerStateEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .managerStateEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .managerStateEvent(v)
        }
      }()
      case 2: try {
        var v: Bleproxy_V1_ScanResultEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .scanResultEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .scanResultEvent(v)
        }
      }()
      case 3: try {
        var v: Bleproxy_V1_PeripheralConnectedEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .peripheralConnectedEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .peripheralConnectedEvent(v)
        }
      }()
      case 4: try {
        var v: Bleproxy_V1_PeripheralDisconnectedEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .peripheralDisconnectedEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .peripheralDisconnectedEvent(v)
        }
      }()
      case 5: try {
        var v: Bleproxy_V1_CharacteristicValueUpdatedEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .characteristicValueUpdatedEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .characteristicValueUpdatedEvent(v)
        }
      }()
      case 6: try {
        var v: Bleproxy_V1_ServerErrorEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .serverErrorEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .serverErrorEvent(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .managerStateEvent?: try {
      guard case .managerStateEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .scanResultEvent?: try {
      guard case .scanResultEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .peripheralConnectedEvent?: try {
      guard case .peripheralConnectedEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .peripheralDisconnectedEvent?: try {
      guard case .peripheralDisconnectedEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .characteristicValueUpdatedEvent?: try {
      guard case .characteristicValueUpdatedEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .serverErrorEvent?: try {
      guard case .serverErrorEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Bleproxy_V1_WsEvent, rhs: Bleproxy_V1_WsEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
